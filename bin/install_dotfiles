#!/usr/bin/env ruby
require 'erb'

REPO = File.absolute_path("#{File.dirname(__FILE__)}/..").freeze
HOME = ENV['HOME']
DIFF_WARNING = <<WARNING.freeze
#{File.basename(__FILE__)} will overwrite the following config files, \
making these changes. If you want to save any of your current \
configuration, please do so before continuing.

(Note: You can add custom bash configuration to `#{HOME}/.profile` and \
it will be automatically loaded.)
WARNING

FILES = [
  "bash_profile",
  "bashrc",
  "eslintrc",
  "gemrc",
  "gitconfig",
  "gitignore",
  "pryrc",
  "railsrc",
  "rspec",
  "rubocop.yml",
  "sqliterc",
  "atom/config.cson"
].freeze

class Dotfile
  DIR = "#{REPO}/dot".freeze

  attr_reader :name

  def self.record_aa_config_dir
    File.write("#{HOME}/.aa_config_dir", DIR)
  end

  def self.remove_broken_symlinks
    `find -L "#{HOME}" -maxdepth 1 -type l -exec rm {} +`
  end

  def initialize(name)
    @name = name
    @diffed = false
  end

  def diff
    @diff ||= compile_diff
  end

  def changed?
    !diff.empty?
  end

  def install
    ensure_parent_dir
    File.write(target_path, text)
  end

  def source_path
    "#{DIR}/#{name}"
  end

  def target_path
    "#{HOME}/.#{name}"
  end

  def compiled_path
    "#{File.dirname(source_path)}/.diff_#{File.basename(source_path)}"
  end

  def text
    @text ||= ERB.new(File.read(source_path)).result
  end

  def compile_diff
    File.write(compiled_path, text)
    diff = `diff #{target_path} #{compiled_path} 2>/dev/null`
    File.delete(compiled_path)
    diff || ''
  end

  def remove_symlink
    `[[ -L #{target} ]] && rm #{target}`
  end

  def ensure_parent_dir
    `mkdir -p "$(dirname "#{target_path}")"`
  end
end

class GitConfig

  def self.[](key)
    result = `git config --global #{key}`
    result = nil if result.empty?
    result
  end

  def self.[]=(key, value)
    `git config --global #{key} "#{value}"`
  end

  def self.cache_user_info
    @git_name = self['user.name']
    @git_email = self['user.email']
  end

  def self.restore_user_info
    self['user.name'] = @git_name if @git_name
    self['user.email'] = @git_email if @git_email
  end

  def initialize
    raise NotImplementedError, "class not meant to be instantiated"
  end
end

def install_dotfiles
  GitConfig.cache_user_info

  dotfiles = FILES.map do |name|
    Dotfile.new(name)
  end

  changed = dotfiles.select(&:changed?)

  if changed.empty? || user_consents?(changed)
    dotfiles.each(&:install)
    GitConfig.restore_user_info
    puts "Dotfiles successfully installed!"
  else
    puts "Dotfiles installation cancelled."
  end
end

def user_consents?(changed_dotfiles)
  puts diff_warning(changed_dotfiles)
  puts "\nContinue? (y/n)"
  gets.downcase.include?('y')
end

def diff_warning(changed_dotfiles)
  diffs = changed_dotfiles.map do |dotfile|
    title = dotfile.target_path
    "#{title}:\n#{'-' * title.length}\n#{dotfile.diff}"
  end
  "#{DIFF_WARNING}\n#{diffs.join("\n")}"
end

install_dotfiles if __FILE__ == $PROGRAM_NAME
